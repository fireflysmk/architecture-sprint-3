
# Задание 1. Анализ и планирование

## 1.  Изучите функциональность монолитного приложения:
    
*   **Управление отоплением.** Пользователи могут удалённо включать/выключать отопление в своих домах.
        
*   **Мониторинг температуры.** Система получает данные о температуре с датчиков, установленных в домах. Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
        
## 2.  Проанализируйте архитектуру монолитного приложения:
    
*   **Язык программирования:** Java
        
*   **База данных:** PostgreSQL
        
*   **Архитектура:** Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
        
*   **Взаимодействие:** Синхронное, запросы обрабатываются последовательно.
        
*   **Масштабируемость:** Ограничена, так как монолит сложно масштабировать по частям.
        
*   **Развёртывание:** Требует остановки всего приложения.
        

## 3.  Определение доменов и границ контекстов
*  **Управление отоплением (Heating Control):** Обработка запросов на включение и выключение отопления. Управляет состоянием устройства отопления в домах.
    
*  **Мониторинг температуры (Temperature Monitoring):** Получает и обрабатывает данные о температуре из установленных датчиков, хранит их и предоставляет доступ для пользователей.
        
*  **Управление устройствами (Device Management):** Домен для подключения и управления устройствами. В будущем он будет ответственен за поддержку и настройку различных устройств (например, освещение, камеры, ворота).
        
*  **Аутентификация и авторизация (Authentication & Authorization):** Обеспечивает безопасность, управляет доступом пользователей к системе, их правами и сессиями.
    
*  **Управление уведомлениями (Notification Management):** Домен для обработки и отправки уведомлений пользователям о статусе системы, например, уведомлений о текущем статусе температурного режима или о том, что датчик вышел из строя.
    

## 4.  Анализ проблем монолитного приложения

Монолитная архитектура приложения имеет несколько недостатков, особенно в контексте целей по расширению функциональности и масштабирования

* **Сложность масштабирования:** С монолитной структурой невозможно гибко масштабировать отдельные компоненты системы.
        
* **Ограниченная гибкость и расширяемость:** Сложность добавления новой функциональности (например, управление другими устройствами) и поддержки системы.
        
* **Проблемы с развёртыванием и обновлениями:** Развёртывание новой версии требует остановки всего приложения, что может приводить к простоям.
        
* **Низкая отказоустойчивость:** В случае отказа одной функции, например, мониторинга температуры, может нарушиться работа всей системы.
        
* **Зависимость от синхронного взаимодействия:** Ограничения, связанные с использованием синхронных операций.
    

Текущая монолитная архитектура представляет собой ограничение для реализации бизнес-целей компании, поскольку затрудняет внедрение новых функций и управление масштабированием.

## 5. Визуализация контекста системы (Context Diagram)

C4 - Уровень контекста (Context) - 1_Monolith_Context_Diagram.puml






# Задание 2. Проектирование микросервисной архитектуры

## 1. Декомпозиция приложения на микросервисы

Основываясь на выделенных доменах и бизнес-целях, микросервисы можно разделить следующим образом:

#### Основные микросервисы

1.  **Heating Control (Управление отоплением):**
    
*   Управляет включением и выключением отопления.
        
*   Поддерживает сценарии работы в зависимости от внешних условий и предпочтений пользователя.
        
2.  **Temperature Monitoring (Мониторинг температуры):**
    
*   Получает данные о температуре с датчиков и сохраняет их для дальнейшего использования.
        
*   Предоставляет данные в реальном времени для просмотра пользователем.
        
3.  **Device Management (Управление устройствами):**
    
*   Управляет подключением новых устройств, таких как освещение, ворота и т.д.
        
*   Поддерживает работу с устройствами партнёров по стандартным протоколам.
        
4.  **User Management (Управление пользователями):**
    
*   Обеспечивает регистрацию, аутентификацию и авторизацию пользователей.
        
*   Управляет правами и настройками пользователя для управления их устройствами.
        
5.  **Notification Service (Служба уведомлений):**
    
*   Отправляет уведомления пользователям (например, об изменении температуры, неисправностях и т.д.).
        
*   Поддерживает несколько каналов уведомлений, таких как e-mail, push-уведомления и SMS.
        
6.  **Scenario Management (Управление сценариями):**
    
*   Позволяет пользователям создавать и управлять сценариями автоматизации (например, включение света при открытии ворот или включение отопления при низкой температуре).
        
*   Обеспечивает возможность гибкой настройки сценариев.
        
7.  **Logging & Monitoring (Логирование и мониторинг):**
    
*   Сохраняет логи и метрики для аналитики и диагностики системы.
        
*   Поддерживает централизованное хранилище для логов всех микросервисов и аналитических данных.
        

#### Дополнительные компоненты архитектуры

1.  **API Gateway:** обеспечивает единый точку входа для всех клиентских запросов, управляет маршрутизацией к микросервисам, обеспечивает аутентификацию и авторизацию, и может выполнять базовую обработку запросов.
    
2.  **Message Broker (Kafka):** используется для асинхронного обмена сообщениями между микросервисами, что повышает гибкость и надёжность системы.
    

## 2. Взаимодействия между компонентами

#### Основные взаимодействия:

1.  **API Gateway и микросервисы:**
    
*   API Gateway будет обрабатывать все внешние запросы (от мобильных и веб-клиентов) и направлять их к соответствующим микросервисам.
        
*   Он также обрабатывает аутентификацию и авторизацию пользователей.
        
2.  **Микросервисы и Kafka:**
    
Микросервисы используют Kafka для публикации и подписки на события. Например:
        
*   **Temperature Monitoring** публикует обновления температуры, на которые подписаны **Heating Control** и **Notification Service**.
            
*   **Device Management** публикует события о подключении новых устройств, которые могут обрабатываться другими микросервисами, например, для автоматической настройки уведомлений.
            
3.  **Микросервисы и база данных:**
    
Каждый микросервис имеет свою собственную базу данных. Например:
        
*   **User Management** — база данных для информации о пользователях и их учетных данных.
            
*   **Temperature Monitoring** — база данных для хранения истории температурных данных.
            

## 3. Визуализация архитектуры:

!! Диаграммы открываются без ошибок в http://www.plantuml.com/ 

*   C4 — Уровень контейнеров (Containers) - C4_2_TOBE_Container.puml
*   C4 — Уровень компонентов (Components) - C4_3_TOBE_Components.puml

        Пример диаграммы Components для сервиса Device Management Service 
*   C4 — Уровень кода (Code) - C4_4_TOBE_Code.puml

        Пример диаграммы Code для сценария добавления нового устройства.




# Задание 3. Разработка ER-диаграммы


## 1. Определение сущностей и их атрибутов

1.  **Пользователь (User):**
    
*   user\_id (PK) — уникальный идентификатор пользователя.
       
*   name — имя пользователя.
        
*   email — электронная почта.
        
*   password\_hash — хэш пароля для аутентификации.
        
*   phone\_number — телефонный номер пользователя.
        
2.  **Дом (House):**
    
*   house\_id (PK) — уникальный идентификатор дома.
        
*   user\_id (FK) — идентификатор владельца дома (внешний ключ к User).
        
*   address — адрес дома.
       
*   name — название дома (например, «Загородный дом»).
        
3.  **Устройство (Device):**
    
*   device\_id (PK) — уникальный идентификатор устройства.
        
*   device\_type\_id (FK) — тип устройства (внешний ключ к DeviceType).
        
*   house\_id (FK) — идентификатор дома, к которому привязано устройство.
        
*   serial\_number — серийный номер устройства.
        
*   status — текущее состояние устройства (например, включено/выключено).
        
4.  **Тип устройства (DeviceType):**
    
*   device\_type\_id (PK) — уникальный идентификатор типа устройства.
        
*   type\_name — название типа устройства (например, «Термостат», «Камера», «Датчик освещения»).
        
*   description — описание типа устройства.
        
5.  **Модуль (Module):**
    
*   module\_id (PK) — уникальный идентификатор модуля.
        
*   name — название модуля (например, «Отопление», «Охрана»).
        
*   description — описание модуля.
        
6.  **Телеметрия (TelemetryData):**
    
*   telemetry\_id (PK) — уникальный идентификатор записи телеметрии.
        
*   device\_id (FK) — идентификатор устройства, к которому относится запись.
        
*   timestamp — дата и время создания записи.
        
*   temperature — значение температуры (если устройство — термостат).
        
*   status — статус устройства в момент записи.
        
*   other\_data — дополнительные данные (в зависимости от устройства).


## 2. Определение связей между сущностями

*   **User-House**: Один пользователь может быть связан с несколькими домами, но каждый дом имеет только одного пользователя. (Связь «Один-ко-многим»)
    
*   **House-Device**: Один дом может содержать несколько устройств, каждое устройство привязано к одному дому. (Связь «Один-ко-многим»)
    
*   **Device-DeviceType**: Каждое устройство имеет один тип, а тип может быть общим для нескольких устройств. (Связь «Один-ко-многим»)
    
*   **Device-TelemetryData**: Одно устройство может генерировать множество записей телеметрии. (Связь «Один-ко-многим»)
    
*   **Module-Device**: Один модуль может включать несколько устройств, но устройство может принадлежать только одному модулю. (Связь «Один-ко-многим»)

## Описание связей:
*   **User (Пользователь)** связан с **House (Дом)** через связь «один-ко-многим» (один пользователь владеет несколькими домами).
*   **House** связан с **Device (Устройство)** через связь «один-ко-многим» (один дом содержит несколько устройств).
*   **Device** связан с **Module (Модуль)** через связь «один-ко-многим» (одно устройство может содержать несколько модулей).
*   **Device** связан с **TelemetryData (Телеметрия)** через связь «один-ко-многим» (одно устройство генерирует множество записей телеметрии).
*   **Device** связан с **DeviceType (Тип устройства)** через связь «многие-к-одному» (несколько устройств могут быть одного типа).


## 4. ER-диаграмма на PlantUML
!! Диаграмма открывается без ошибок в http://www.plantuml.com/ 

ER-диаграмма - C4_5_TOBE_ER.puml 



----------


# Часть 2. Проектирование API


## 1. Выбор API и назначение микросервисов

Для синхронных операций, таких как запрос и управление состоянием устройства, будем использовать REST API. Для асинхронных уведомлений, таких как новые данные телеметрии, используем AsyncAPI на базе Kafka.

Выделим следующие микросервисы:

1.  **User Service**  (сервис управления пользователями)
2.  **Device Management Service**  (сервис управления устройствами)
3.  **Telemetry Service**  (сервис сбора телеметрии)


## 2. Проектирование API для выбранных микросервисов

### 1.  **User Service**

Управляет данными пользователей и позволяет управлять информацией о пользователях.

-   **POST /users**  — создать нового пользователя
    
	-   **Запрос**:

	```json
	{
		"name": "Daniil Kustov",
		"email": "DaniilKustov@gmail.com",
		"password": "password"
	}
	```    
	-   **Ответы**:
		-   **201 Created**: Пользователь успешно создан.
 
		```json
		{
			"id": "123e4567-e89b-12d3-a456-426614174000",
			"name": "Daniil Kustov",
			"email": "DaniilKustov@gmail.com"
		}
		```

   		-   **400 Bad Request**: Ошибка валидации данных.



-   **GET /users/{userId}**  — получить данные пользователя по ID
    
	-   **Ответы**:
	        -   **200 OK**: Успешное получение данных.
	            
		```json
		{
			"id": "123e4567-e89b-12d3-a456-426614174000",
			"name": "Daniil Kustov",
		        "email": "DaniilKustov@gmail.com"
		}
		``` 
		-   **404 Not Found**: Пользователь не найден.



### 2.  **Device Management Service**

Управляет устройствами, связанными с домами, позволяет включать и выключать устройства, а также управлять их состоянием.

-   **POST /devices**  — добавить новое устройство
    
	-   **Запрос**:
        
	```json
	{
	       	  "serial_number": "ABC123456",
	       	  "type_id": "thermostat",
	       	  "house_id": "house123",
	       	  "status": "offline"
	}
	``` 
				
	-   **Ответы**:
        	-   **201 Created**: Устройство успешно добавлено.

		```json
		{	           {
		        "id": "device123",
		        "serial_number": "ABC123456",
		        "status": "offline",
		        "type_id": "thermostat",
			"house_id": "house123"
		}
		``` 
-   **PATCH /devices/{deviceId}/status**  — обновить статус устройства (включено/выключено)
    
	-   **Запрос**:

	```json
	{
		"status": "online"
	}
	``` 
	-   **Ответы**:
	        -   **200 OK**: Устройство успешно обновлено.
	        -   **404 Not Found**: Устройство не найдено.
   		-   **500 Internal Server Error**: Ошибка сервера.



### 3.  **Telemetry Service**

Собирает и обрабатывает телеметрические данные с устройств. Для передачи данных используется Kafka.

-   **AsyncAPI Channel**:  **telemetry/temperature**
    -   Описание: Получение новых данных о температуре от устройства.
        
    -   **Payload**:
        
	```json
	{
		"device_id": "device123",
		"timestamp": "2023-01-01T12:00:00Z",
		"temperature": 22.5
	}
	``` 
    -   **Ответы**:
        
        -   При успешной обработке данных система отправляет уведомление об успешной записи данных для аналитики.



### 3. Описание контрактов API и примеры

#### Пример контракта API: Device Management Service

-   **Метод**:  `POST /devices`
    
    -   **Описание**: Добавить новое устройство.
    -   **Тело запроса**:
        
	```json
	{
		"serial_number": "ABC123456",
		"type_id": "thermostat",
		"house_id": "house123",
		"status": "offline"
	}
	``` 
 
-   **Ответы**:
        -   **201 Created**:
            
	```json
	{
		"id": "device123",
		"serial_number": "ABC123456",
		"status": "offline",
		"type_id": "thermostat",
		"house_id": "house123"
	}
	```  
       
  	-   **400 Bad Request**: Ошибка валидации данных.

-   **Метод**:  `PATCH /devices/{deviceId}/status`
    
    -   **Описание**: Обновить статус устройства.
    -   **Тело запроса**:
        
	```json
	{
		"status": "online"
	}
	```         
    -   **Ответы**:
        -   **200 OK**:
            
	```json
	{
 		"id": "device123",
		"status": "online"
	}
	```     
        
	-   **404 Not Found**: Устройство не найдено.



### 4. Документирование API с помощью Swagger и AsyncAPI

1.  **User Service**  (сервис управления пользователями) - /API/UserService.yaml
2.  **Device Management Service**  (сервис управления устройствами) - /API/DeviceManagementSystem.yaml
3.  **Telemetry Service**  (сервис сбора телеметрии) - /API/TelemetryService.yaml


