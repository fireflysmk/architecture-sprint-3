# Анализ и планирование

## Изучите функциональность монолитного приложения:

Изучил два функционала управление отоплением и мониторинг температуры

## Проанализируйте архитектуру монолитного приложения:
Наблюдаю все минусы монолита: ограниченная масштабируемасть, сложная развертка, через чур сильная зависимость между компонентами. Также функционал построен только на синхронном взаимодействии, что ограничивает гибкость. В будущем стоит ввести спользование Docker и CI/CD-подходов

## Определите домены и границы контекстов
Управление Устройствами (Device Management)<br/>
Мониторинг Температуры (Temperature Monitoring)<br/>
Пользовательский Интерфейс (User Interface)<br/>
Регулирование Температуры (Temperature Regulation)<br/>

# Архитектура микросервисов

## Микросервисы и паттерны для взаимодействия
Управление устройствами (Device Management Service) - регулирование температуры. Для управления доступом к устройствам можно использоваться API Gateway<br/>
Мониторинг температуры (Temperature Monitoring Service) - обрабатывает данные с датчиком. Можно использовать кафку для асинхронного взаимодействия<br/>
Регулирование температуры (Temperature Regulation Service) - требует выделенной логики и может быть реализован как паттерн Saga<br/>
Пользовательский интерфейс (User Interface Service) - для быстро обработки ответа пользователю. Можно использовать паттерны BFF и CQRS<br/>
Уведомления (Notification Service) - для отправки уведомлений пользователю. Можно использовать event-driven architecture

# ER-диаграмма
User — House: один пользователь может иметь доступ к нескольким домам, но каждый дом связан только с одним пользователем.<br/> Один пользователь может управлять отоплением в нескольких домах или квартирах, но каждый дом может управляться только одним владельцем.<br/> Связь: user_id в таблице House является внешним ключом, указывающим на таблицу User.<br/>

House — Device: один дом может содержать несколько устройств, и каждое устройство принадлежит только одному дому.<br/> В доме может быть установлено несколько устройств для управления отоплением (например, несколько термостатов или радиаторов), и все они связаны с этим домом.<br/> Связь: house_id в таблице Device является внешним ключом, указывающим на таблицу House.<br/>

Device — DeviceType: один тип устройства может использоваться для множества устройств, но каждое устройство относится только к одному типу.<br/> Несколько устройств могут быть термостатами одного типа, но каждое устройство связано с одним конкретным типом.<br/> Связь: type_id в таблице Device является внешним ключом, указывающим на таблицу DeviceType.<br/>

Device — Module: одно устройство может содержать несколько модулей, но каждый модуль принадлежит только одному устройству.<br/> В системе отопления может быть несколько модулей, управляющих разными зонами в доме, все они связаны с одним устройством.<br/> Связь: device_id в таблице Module является внешним ключом, указывающим на таблицу Device.<br/>

Device — TelemetryData: одно устройство может генерировать множество записей телеметрии, но каждая запись телеметрии относится только к одному устройству.<br/> Устройство, такое как термостат, регулярно отправляет данные о текущей температуре, и эти данные записываются как отдельные записи телеметрии.<br/> Связь: device_id в таблице TelemetryData является внешним ключом, указывающим на таблицу Device.<br/>

User — Settings: один пользователь может иметь несколько наборов настроек для разных домов, но каждый набор настроек принадлежит только одному пользователю.<br/> Пользователь может устанавливать различные предпочтения для температурных режимов в разных домах.<br/> Связь: user_id в таблице Settings является внешним ключом, указывающим на таблицу User.<br/>

House — Settings: один дом может иметь несколько наборов настроек (например, для разных помещений или временных периодов), но каждый набор настроек принадлежит только одному дому.<br/> Дом может иметь несколько разных температурных режимов для разных помещений или времён суток.<br/> Связь: house_id в таблице Settings является внешним ключом, указывающим на таблицу House.<br/>

Device — ControlCommand: одно устройство может получать множество команд управления, но каждая команда управления относится только к одному устройству.<br/> На одно устройство может отправляться несколько команд, таких как включение, выключение, изменение температуры.<br/> Связь: device_id в таблице ControlCommand является внешним ключом, указывающим на таблицу Device.<br/>

Device — Event: одно устройство может генерировать множество событий, но каждое событие связано только с одним устройством.<br/> Устройство может генерировать события, такие как изменение температуры или изменение состояния (включение/выключение).<br/> Связь: device_id в таблице Event является внешним ключом, указывающим на таблицу Device.<br/>

User — Notification: один пользователь может получать множество уведомлений, но каждое уведомление связано только с одним пользователем.<br/> Пользователь может получать уведомления о состоянии устройства, выполнении команды или аварийных ситуациях.<br/> Связь: user_id в таблице Notification является внешним ключом, указывающим на таблицу User.<br/>

Event — Notification: одно событие может генерировать несколько уведомлений для разных пользователей, но каждое уведомление связано только с одним событием.<br/> При достижении заданной температуры может генерироваться событие, которое инициирует уведомление нескольких пользователей.<br/> Связь: event_id в таблице Notification является внешним ключом, указывающим на таблицу Event.<br/>

Task — Event: одна задача может вызывать несколько событий, но каждое событие связано с одной задачей.<br/> Задача может регулярно проверять температуру в доме, и при изменении она генерирует событие.<br/> Связь: task_id в таблице Event является внешним ключом, указывающим на таблицу Task.<br/>

# Создание и документирование API

## 1. Получить информацию об устройстве
**Метод**: `GET` `/devices/{id}`

**Описание**: Получить информацию о конкретном устройстве по его идентификатору.

**Параметры:**
- `id` (path) - Идентификатор устройства.

**Формат ответа**:
```json
{
  "id": "string",
  "type_id": "string",
  "house_id": "string",
  "serial_number": "string",
  "status": "string"
}
```

### 2. Включить устройство
**Метод**: `POST` `/devices/{id}/turn-on`

**Описание**: Этот эндпойнт позволяет включить устройство по его идентификатору.

**Параметры:**
- `id` (path) - Идентификатор устройства, которое нужно включить.

**Тело запроса**:
```json
{
  "user_id": "string"
}
```

### 3. Получить текущую температуру в доме
**Метод**: `GET` `/houses/{id}/current-temperature`

**Описание**: Этот эндпойнт позволяет получить текущую температуру в указанном доме по его идентификатору.

**Параметры:**
- `id` (path) - Идентификатор дома, для которого нужно получить текущую температуру.

**Формат ответа**:
- **Успех (200)**:
```json
{
  "house_id": "string",
  "current_temperature": "number",
  "timestamp": "string"
}
```

### 4. Обновить настройки температуры в доме
**Метод**: `PUT` `/houses/{id}/temperature-settings`

**Описание**: Этот эндпойнт позволяет обновить настройки желаемой температуры и расписания в указанном доме.

**Параметры:**
- `id` (path) - Идентификатор дома, для которого нужно обновить настройки температуры.

**Тело запроса**:
```json
{
  "desired_temperature": "number",
  "schedule": [
    {
      "day": "string",
      "start_time": "string",
      "end_time": "string"
    }
  ]
}
```

### 5. Получить уведомления пользователя
**Метод**: `GET` `/users/{id}/notifications`

**Описание**: Этот эндпойнт позволяет получить список уведомлений для указанного пользователя по его идентификатору.

**Параметры:**
- `id` (path) - Идентификатор пользователя, для которого нужно получить уведомления.

**Формат ответа**:
- **Успех (200)**:
```json
{
  "user_id": "string",
  "notifications": [
    {
      "notification_id": "string",
      "message": "string",
      "timestamp": "string",
      "is_read": "boolean"
    }
  ]
}
```